(*Make a get_variable function*)
(*Make a get_pointer function*)
(*Make a check function*)
(*Make a translate function*)
(*Make a get_frame function*)
(*Make a callable function*)
(*Make a accesible_variables function*)
(*Make a find_parent function*)
(*Make a copy function*)
(*Make a paste function*)
(* Type definition for the expression parse tree generated by the parser *)
type expr_tree = NULL | Return | Assign of expr_tree*expr_tree | Call of expr_tree*(expr_tree list) | Var of string | Int of int | F of string

exception Empty 
exception Invalid
exception Invalid2
exception Invalid3
exception Invalid4
exception Not_accesible

let a=ref(Var "a",0)
let b=ref(Var "b",0)
let c=ref(Var "c",0)
let x=ref(Var "x",0)
let y=ref(Var "y",0)
let z=ref(Var "z",0)
let w=ref(Var "w",0)
let i=ref(Var "i",0)
let j=ref(Var "j",0)
let k=ref(Var "k",0)
let n=ref(Var "n",0)
let m=ref(Var "m",0)
let p=ref(Var "p",0)
let g=ref(Var "g",0)
let h=ref(Var "h",0)

let get_pointer (t:expr_tree) =(match t with
                                Int(intvalue)->ref((Int(intvalue),intvalue))
                                |Var("a")->a
                                |Var("b")->b
                                |Var("c")->c
                                |Var("x")->x
                                |Var("y")->y
                                |Var("z")->z
                                |Var("w")->w
                                |Var("i")->i
                                |Var("j")->j
                                |Var("k")->k
                                |Var("n")->n
                                |Var("m")->m
                                |Var("p")->p
                                |Var("g")->g
                                |Var("h")->h
                                )

type fp=Frame of (((((expr_tree*int)) list)ref)*(expr_tree)*((expr_tree) list)*((((expr_tree*int)) list)ref)*(((expr_tree*int)) list)) (*Frame of (arguments)x(parent)x(children procedures)x(Defined Variables)x(Store Defined Variables upon call and retrieve upon return)*) 


let (mainfunc:fp)=((Frame(ref([]),NULL,([F("P");F("Q")]),ref([(Var"a",0);(Var"b",0);(Var"c",0)]),([]))))
let (pfunc:fp )=((Frame(ref([(Var"x",0);(Var"y",0)]),F"Main",([F("R");F("S")]),ref([(Var"z",0);(Var"a",0)]),([]))))
let (qfunc:fp )=( (Frame(ref([(Var"z",0);(Var"w",0)]),F"Main",([F("T");F("U")]),ref([(Var"x",0);(Var"b",0)]),([]))))
let (rfunc:fp )=( (Frame(ref([(Var"w",0);(Var"i",0)]),F"P",([F("V")]),ref([(Var"j",0);(Var"b",0)]),([]))))
let (sfunc:fp )=( (Frame(ref([(Var"c",0);(Var"k",0)]),F"P",([]),ref([(Var"n",0);(Var"m",0)]),([]))))
let (tfunc:fp )=( (Frame(ref([(Var"a",0);(Var"y",0)]),F"Q",([F("W")]),ref([(Var"m",0);(Var"p",0)]),([]))))
let (ufunc:fp )=( (Frame(ref([(Var"c",0);(Var"z",0)]),F"Q",([]),ref([(Var"p",0);(Var"g",0)]),([]))))
let (vfunc:fp )=( (Frame(ref([(Var"m",0);(Var"n",0)]),F"R",([]),ref([(Var"c",0)]),([]))))
let (wfunc:fp )=( (Frame(ref([(Var"m",0);(Var"p",0)]),F"T",([]),ref([(Var"j",0);(Var"h",0)]),([]))))

let get_func (t:fp)=(match t with
                                mainfunc->F"Main"
                                |pfunc->F("P") 
                                |qfunc->F("Q")
                                |rfunc->F("R")
                                |sfunc->F("S")
                                |tfunc->F("T")
                                |ufunc->F("U")
                                |vfunc->F("U")
                                |wfunc->F("W")
                            )
            
let get_frame (t:expr_tree)=(match t with
                                F("Main")->mainfunc
                                |F("P")->pfunc
                                |F("Q")->qfunc
                                |F("R")->rfunc
                                |F("S")->sfunc
                                |F("T")->tfunc
                                |F("U")->ufunc
                                |F("V")->vfunc
                                |F("W")->wfunc
                            )

type stack= Stack of ((fp) list)  (* Stack showing functions called upto this point*)
let (sr:stack ref)=ref (Stack([mainfunc]))   (* Stack showing functions called upto this point*)
type callables= Callables of ((expr_tree) list)  (*List of procedures that can be called at this point*)
let (cr:callables ref)=ref (Callables([F"P";F"Q"])) (*List of procedures that can be called at this point*)
type variables= Variables of (((expr_tree*int)) list) (*List of accesible variables at this point*)
let (vr:variables ref)=ref (Variables([(Var"a",0);(Var"b",0);(Var"c",0)])) (*List of accesible variables at this point*)
type display= Display of (((fp) ref) list)  (*Display Register*)
let (dr:display ref)=ref (Display([ref(mainfunc)])) (*Display Register*)

let rec convert (l1)=(match l1 with
                        ([])->([])
                        | (x0::[])->(match x0 with (Var(str),intvalue) ->([Var(str)]))
                        |(x0::xs)->(match x0 with (Var(str),intvalue) ->(((Var(str)))::(convert xs))))

let rec convert2 (l1)=(match l1 with
                         (x0::[])->(match x0 with (Var(str),intvalue) ->([intvalue]))
                        |(x0::xs)->(match x0 with (Var(str),intvalue) ->(((intvalue))::(convert2 xs))))

let rec find (t:expr_tree) (v:variables)=(match v with Variables(l1)->( match (convert (l1)) with
                                []->false
                                |(x0::xs)->(if (t=x0) then true else (find t (Variables(List.tl l1))))))

let rec do_it t x=(match x with (a,b)->(t,b))

let rec replace (t:expr_tree) (x) (lr) (v:variables) ltemp=(match v with Variables(l1)->(match l1 with []->() | (x0::xs)->(match x0 with (a,b)->if (a=t) then (lr:=(ltemp@[(do_it t x)]@xs)) else (replace t x lr (Variables(List.tl l1)) (ltemp@[x]) ) ) ))



let rec check (t:expr_tree) (calls:callables)=(match calls with Callables(l1)->( match l1 with
                                []->false
                                |(x0::xs)->(if (t=x0)then true else (check t (Callables(xs))))))

let rec find_parent (t:expr_tree)=(match t with 
                                    (F"Main")->([F"Main"])
|(F(str))->(match (get_frame(t)) with (Frame(l1,l2,l3,l4,l5))->(t::(find_parent l2))))

let rec find_callable (t:expr_tree)=(match (find_parent(t)) with
                                    x0::[]->(match (get_frame x0) with ((Frame(_,_,l3,_,_)))->l3)
                                    |(x0::(y0::xs))->(match (get_frame x0) with ((Frame(_,_,l3,_,_)))->l3@(find_callable(y0)))
                                    )
(* let rec modified l1=(match l1 with (x0::[])->[(!x0)]
                                    |(x0::xs)->((!x0)::(modified xs))) *)

let rec setof (l1:(((expr_tree*int)) list)) (l2:(((expr_tree*int)) list))=(match l1 with (x0::[])->(match (x0) with (Var(str),intvalue)-> if (find (Var(str)) (Variables(l2))) then [] else [x0])
                        |(x0::xs)->(match (x0) with (Var(str),intvalue)-> if (find (Var(str)) (Variables(l2))) then ([]@(setof xs l2)) else ([x0]@(setof xs l2))))
let rec accesible_variables (t)=(match (t) with 
                                            (Display(x::[]))->(match !x with Frame(l1,l2,l3,l4,l5)->((!l1)@(!l4)))
                                            |(Display(x::xs))->(match !x with Frame(l1,l2,l3,l4,l5)->((!l1)@(!l4))@( setof (accesible_variables (Display(xs))) ((!l1)@(!l4)) ) ) )(* (match (a,b,c) with ((Var"a",value1),(Var"b",value2),(Var"c",value3))->)[Var"a",;Var"b";Var"c"] *)

let rec find_inside t l=(match l with ([])->false | (x::xs)->(match x with (a,b)-> if(t=a)then true else (find_inside t xs)))

let rec returnit t l=(match l with (x::xs)->(match x with (a,b)-> if(t=a)then x else (returnit t xs)))

let rec get_variables t a=(match t with Int(num)->(Int(num),num)| Var(str)->(match a with Display(x::xs)->(match !x with Frame(l1,l2,l3,l4,l5)-> if ( find_inside t ((!l1)@(!l4)) ) then (returnit t ((!l1)@(!l4)) ) else (get_variables t (Display(xs))) )))

let rec translate l1 t2 ltemp=(match !l1 with ((x0)::[])->(match (x0) with (Var(str),intvalue)->(match ((get_variables(List.hd t2) !dr)) with (alpha,intvalue2) ->l1:=((Var(str),intvalue2)::ltemp)))
                            |(x0::xs)->((match (x0) with (Var(str),intvalue)->(match ((get_variables(List.hd t2) !dr)) with (alpha,intvalue2) ->(translate l1 (List.tl t2) (ltemp@([(Var(str),intvalue2)]))) ))))

let get_2 (l1)=(match l1 with (x0::[])->raise Invalid
                    |(x0::(y0::xs))->y0)
let rec converter t=(match (get_func t) with F(str)->str ) 

let rec printflist l1=(match l1 with (F(str)::[])->print_endline (str^" ")
                                    |(F(str)::xs)->(print_endline  (str^" ")); printflist xs)
let rec printvarlist l1=(match ((convert l1), (convert2 l1)) with ((Var(str)::[]),(intvalue::[]))->print_endline  (str^"="^string_of_int(intvalue))
                                    |((Var(str)::xs),(intvalue::ys))->print_endline  (str^"="^string_of_int(intvalue)); printvarlist (List.tl l1))
let rec printfplist l1=(match l1 with (x::[])->print_endline ((converter(x))^" ")
                                    |(x::xs)->(print_endline  ((converter(x))^" ")); printfplist xs)
let rec printfprlist l1=(match l1 with (x::[])->printfplist [(!x)]
						|(x::xs)->printfplist [(!x)] ; printfprlist (xs))
(* Function to evaluate value given the parse tree *)
let rec find_in_list t l1=(match l1 with (x1::xs)-> if (t=x1) then x1 else (find_in_list t xs) )
let rec find_in_stack(t:fp)=(match !sr with Stack(l1)->(find_in_list t l1))
let rec find_link (t:fp)=(match t with mainfunc->([])
|a1->(match a1 with Frame(l1,l2,l3,l4,l5)->(ref(find_in_stack(get_frame(l2)))::(find_link(get_frame l2)))))

let rec find_variables t v l=(match l with (x::[])->(match !x with Frame(l1,l2,l3,l4,l5)-> (if (find t (Variables(((!l1))))) then (replace t v l1 (Variables(((!l1)))) [] ) else (if (find t (Variables(((!l4))))) then (replace t v l4 (Variables(((!l4)))) []) else raise Not_accesible )   ) )
								|(x::xs)->(match !x with Frame(l1,l2,l3,l4,l5)-> if (find t (Variables(((!l1))))) then (replace t v l1 (Variables(((!l1)))) []) else (if (find t (Variables(((!l4))))) then (replace t v l4 (Variables(((!l4)))) []) else (find_variables t v xs))  ))
let rec find_in_display (t) (v)=(match !dr with Display(l1)-> find_variables t v l1)

let rec printsr pr=(match (!pr) with (Stack(l1))->printfplist l1) 
let rec printcr pr=(match (!pr) with (Callables(l1))->printflist l1) 
let rec printvr pr=(match (!pr) with (Variables(l1))->printvarlist l1)
let rec printdr pr=(match (!pr) with (Display(l1))->printfprlist l1)
let rec eval_tree t = (match t with
    NULL            -> raise Empty
| Return        -> (match !sr with Stack(l1)->((sr:=Stack(List.tl(l1))); dr:=Display((ref(get_2 (l1)))::((find_link ( (get_2 (l1)))))); cr:=Callables(find_callable (get_func(get_2 (l1))));vr:=Variables(accesible_variables (!dr) )))
| Assign(t1,t2) -> (match !vr with (Variables(l1))->(match t1 with 
                        (Var(str))->((if(find ((Var(str))) (Variables(l1)))then
                                        (match t2 with
                                    Int(it)->(find_in_display (Var(str)) (Int(it),it)) 
                                    |Var(str2)->(find_in_display (Var(str)) (get_variables(t2) !dr) ) 
                                        )
                                    else (raise Not_accesible));vr:=Variables(accesible_variables (!dr) ))
                        |_->raise Invalid
                                ))
                        
    | Call(t1,t2)   -> (match (!cr,!sr) with (Callables(l6),Stack(l7))-> (if (check ((t1)) (Callables(l6)) )then (
                                match (get_frame(t1)) with
                             ((Frame(l1,l2,l3,l4,l5)))->((if(List.length t2=List.length (!l1))then(sr:=Stack((get_frame(t1))::(l7));(translate (l1) t2 []);dr:=Display((ref(List.hd l7))::((find_link (get_frame t1) )))(*unit type*);cr:=Callables(find_callable t1);vr:=Variables(accesible_variables (!dr)))else(raise Invalid)) 
                                 )
                             )
                        else raise Invalid2
                        ))
    |_              -> raise Invalid 
                    );printsr sr(*);printcr cr; printvr vr; printdr dr*)
;;
(* Function to print the expression tree, each node labelled with its level/depth *)
(*let rec print_tree t level = match t with
    NULL           -> Printf.printf "Empty Tree\n";
    | NUM(x)       -> Printf.printf "Level %d INT %d " level x;
    | INTO(t1,t2)  -> Printf.printf "Level %d *\n" level; print_tree t1 (level+1); print_tree t2 (level+1); print_newline();
    | PLUS(t1,t2)  -> Printf.printf "Level %d +\n" level; print_tree t1 (level+1); print_tree t2 (level+1); print_newline();
    | VAR(x)       -> Printf.printf "Level %d INT %d " level (VarTable.find x variable_set);
;;*)

(* TODO
 * - Try writing a compile function that converts given parse tree into a postfix code.
 *    You might have to define a new type
 * - Try evaluating compiled expression tree using stack machine
 * *)
