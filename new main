#include <cstdlib>
#include <ctime>
#include <unistd.h>
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <fstream>
#include "Road.h"
#include "Vechile.h"
using namespace std;


void update(vector<Vechile> v,string **s,Road road){
  int i,j,r,q,k;
  int w=0;  
    for(i=0;i<v.size();i++){
	//cout<< "be"<< v.size() <<endl;
    	for(k=1;k<road.getRoad_Width()+1;k++){
		//cout<< "alpha"<< k <<endl;
    		if(v[i].getPosy()==k){
			//cout<< "beta"<< k <<endl;
    			for(r=k;(r>k-v[i].getWidth() && r>0);r--){
		            for(j=0;j<road.getRoad_Length();j++){
					//cout<<endl;
		        		if(v[i].getPosx()==j){
						//cout<< "beta"<< j <<endl;
						//cout<< "alpha" << v[i].getPosx() <<endl;
		        			for(q=j;(q>j-v[i].getLength() && q>=0);q--){
		        				s[q][r]=v[i].getType().substr(0,1);
		        			}
		        		}
		        	}
		        }
    		}
        }    		
    }
}

void display(string **s,Road road){
    for (int i=0;i<road.getRoad_Width()+2;i++){
        for(int j=0;j<road.getRoad_Length();j++){
            cout<<s[j][i];
        }
        cout<<endl;
    }
}

string change(string s){
    int pos = s.find("="); 
    s = s.substr(pos+1);
    return s;
}
string change2(string s){
    int pos = s.find("="); 
    s = s.substr(0,pos);
    return s;
}
int min_2(int a,int b){
	if(b=<0 || a<b){
		return a;
	}
	return b;
}
int minimum_all(vector<int> v){
	int min_all=10000;
	for(int i=0;i<v.size();i++){
		if(v[i]<min_all)
			min_all=v[i];
	}
	return min_all;
}
vector<int> v_clash_x(Vechile v0,vector<Vechile> v){
	vector<int> ret;
	for(int i=0;i<v.size();i++){
		if(v[i]!=v0){
			if((is_between(v[i].getPosy(),v0.getPosy(),v0.getPosy()-v0.getWidth()) || is_between(v[i].getPosy()-v[i].getWidth(),v0.getPosy(),v0.getPosy()-v0.getWidth())) && v[i].getPosx()-v[i].getWidth()>v0.getPosx()){
				ret.push_back(v[i].getPosx()-v[i].getWidth()-v0.getPosx()); //v[i].getPosx-v[i].getWidth-v0.getPosx // this is the xdis b/w the vechiles ,that is >=1
			}
		}
	}
	if(ret.size==0){
		ret.push_back(10000);
	}
	reteurn ret;
}

bool is_between(int a,int b,int c){
	if(a=<b && a>=c ){
		return true;
	}
	return false;
}

int check_x(Vechile v){
	if(v.getDisx()>v.getSpeed()+v.getAcceleration()){
		return v.getSpeed()+v.getAcceleration();
	}
	else if(v.getDisx()<v.getSpeed()+v.getAcceleration() && v.getDisx()>v.getSpeed()){
		return v.getSpeed();
	}
	else if(v.getDisx()>v.getSpeed()-v.getAcceleration() && v.getDisx()<v.getSpeed()){
		return v.getSpeed()-v.getAcceleration(); 
	}
	return 0;
}

//void move_all()

int main(int argc, char* argv[]){
    clock_t start = clock();
    int time = 0;
    Road road;
     
    vector<Vechile> v_vechile;
    int i=0;
    int num;
    //cin>>num
    num=1;
    while(i<num){
    	Vechile v("Car","Green",2,2,1,1,1);
    	v_vechile.push_back(v);
    	i++;
    }
    num=v_vechile.size();
    Vechile vechile[num];
    for(int i=0;i<num;i++)
    	vechile[i]=v_vechile[i];
    vector<Vechile> v_in_vechile;
    i=0;
    Vechile v;
    string **a;
    a=new string*[road.getRoad_Length()];//7
    for(int i=0;i<road.getRoad_Length();i++)
            a[i]=new string[road.getRoad_Width()+2];
    
    for(int i=0;i<road.getRoad_Width()+2;i++){
            for(int j=0;j<road.getRoad_Length();j++){
                    a[j][i]=" ";
            }
    }
    
    
        for(int k=0;k<road.getRoad_Width()+2;k++){
            if(k==0 || k==road.getRoad_Width()+1){
                for(int i=0;i<road.getRoad_Length();i++){
                    a[i][k]="-";
                }
            }
        }
  
/* 
   // while{
	    //if(readline==){
    		Vechile vec=vechile[0]; //later vechile[k]
    		vec.setPosx(0);
    		vec.setPosy(2);
	    	v_in_vechile.push_back(vec);
	    	for(int i=0;i<v_in_vechile.size()-1;i++){
	    		v_in_vechile[i].move();
	    	}
	    //}
*/
	    	
		
	 for(int t=0;t<40;t++){
		//display(a,road);
		//cout<<"a"<<endl;
		if(t==3){
    		Vechile vec=vechile[0]; //later vechile[k]
    		vec.setPosx(0);
    		vec.setPosy(2);
	    	v_in_vechile.push_back(vec);
	    	for(int i=0;i<v_in_vechile.size()-1;i++){
	    		v_in_vechile[i].move();
	    	}
	    }
		if(t==4){
    		Vechile vec=vechile[0]; //later vechile[k]
    		vec.setPosx(0);
    		vec.setPosy(5);
	    	v_in_vechile.push_back(vec);
	    	for(int i=0;i<v_in_vechile.size()-1;i++){
	    		v_in_vechile[i].move();
	    	}
	    }
		if(t!=3 && t!=4){
		for(int i=0;i<v_in_vechile.size();i++){
	    		v_in_vechile[i].move();
	    	}		
		}
	for (int i=1;i<road.getRoad_Width()+1;i++){
	    	for(int j=0;j<road.getRoad_Length();j++){
        	    a[j][i]=" ";
        	}
    	}
	for(int i=0;i<v_in_vechile.size();i++){ //v_in is the vector of vechiles in the road
		v_in_vechile[i].setDisx(min_2(minimum_all(v_clash_x(v_in_vechile[i],v_in_vechile)),road.getRoad_Signal()-v_in_vechile[i].getPosx)); //v_clash_x is a function that returns a vector of x 		distances of vechiles that clash with the given vechile.
	}

	for(int i=0;i<v_in_vechile.size();i++){
		if(check_x(v_in_vechile[i])>=v_in_vechile[i].getMaxSpeed()){
			v_in_vechile[i].setSpeed(v_in_vechile[i].getMaxSpeed());	
		}
		else{
			if(check_x(v_in_vechile[i])<=0){
				v_in_vechile[i].setSpeed(0);
			}
			else{
				v_in_vechile[i].setSpeed(check_x(v_in_vechile[i]));
			}
		}
		
	}

    	update(v_in_vechile,a,road);
    	display(a,road);
	//cout<<"b"<<endl;
	//cout<<v_in_vechile[0].getPosx()<<" "<<v_in_vechile[0].getLength()<<endl;
    //}
	}
    // vechile.push_back((Car,Green,2,2,1,1,0.5)) 
    // Vechile(Car,Green,2,2,1,1,0.5);
    // Vechile(Bus,Red,3,2);
    // Vechile(Truck,Green,4,2);
    // Vechile(bike,Blue,2,1);
	return 0;
}

/*
for(int i=0;i<v_in_vechile.size();i++){
	v_in_vechile[i].setChange_to_Right(check_right(v_in_vechile,v_in_vechile[i]))
}
*/

ifstream infile;
    infile.open("config.ini");
    if(!infile.is_open()){
        cout<< "Error opening file"<< endl;
        return 0;
    }
    //road parameters
    string a1; 
    infile>>a1; a1=change(a1);
    road.setRoad_ID(stoi(a1));
    infile>>a1; a1=change(a1);
    road.setRoad_Length(stoi(a1));
    infile>>a1; a1=change(a1);
    road.setRoad_Width(stoi(a1));
    infile>>a1; a1=change(a1);
    road.setRoad_Signal(stoi(a1));
    
    vector<Vechile> v_vechile;

    string k;
    infile>>k;
    k=change(k); //number of vechiles to be defined
    int t = stoi(k);
    //cout<<t;
    int i=0;
    while(t>0){
        string a1,a2;
        if(i==0){
            infile>>a1;
            infile>>a2;
        }
        else{
            a1=a2;
            infile>>a2;
        }
        while(change2(a2)!="Vechile_Type" ){
            Vechile v;
            v.setType(change(a1)); 
            
                if(change2(a2)=="Vechile_Length")
                    v.setLength(stoi(change(a2))); 
                if(change2(a2)=="Vechile_Width")
                    v.setWidth(stoi(change(a2)));
                if(change2(a2)=="Vechile_MaxSpeed")
                    v.setMaxSpeed(stoi(change(a2)));
                if(change2(a2)=="Vechile_Acceleration")
                    v.setAcceleration(stoi(change(a2)));
                if(change2(a2)=="Vechile_Color")
                    v.setColor(change(a2));
            infile>>a2;
            if(change2(a2)=="Vechile_Type"){
                v_vechile.push_back(v);
            }  
            if(a2=="end"){
                break;
            }
         
        }  
        i++;
        t=t-1;
        //cout<<t<<endl;
}







